<!-- MHonArc v2.6.2 -->
<!--X-Subject: Perl IPS for the BofH in all of us -->
<!--X-From-R13: [ng Qnhtueba <zngNcucpbafhygvat.pbz> -->
<!--X-Date: Tue, 22 Jul 2003 18:02:33 &#45;0500 -->
<!--X-Message-Id: 20030722180435.J42277&#45;100000@phpconsulting.com -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: 3F18A075.C6E13CE5@jays.net -->
<!--X-Head-End-->
<!doctype html public "-//W3C//DTD HTML//EN">
<html>
<head>
<title>Perl IPS for the BofH in all of us</title>
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<a href="msg00155.html">Date Prev</a>][<a href="msg00157.html">Date Next</a>][<a href="msg00152.html">Thread Prev</a>][<a href="msg00154.html">Thread Next</a>][<a href="maillist.html#00156">Date Index</a>][<a href="threads.html#00156">Thread Index</a>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>Perl IPS for the BofH in all of us</h1>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: Jay Hannah &lt;<a href="mailto:jay@DOMAIN.HIDDEN">jay@xxxxxxxx</a>&gt;</li>
<li><em>Subject</em>: Perl IPS for the BofH in all of us</li>
<li><em>From</em>: Mat Caughron &lt;<a href="mailto:mat@DOMAIN.HIDDEN">mat@xxxxxxxxxxxxxxxxx</a>&gt;</li>
<li><em>Date</em>: Tue, 22 Jul 2003 18:10:28 -0500 (CDT)</li>
<li><em>Cc</em>: &lt;<a href="mailto:omaha-list@DOMAIN.HIDDEN">omaha-list@xxxxxxxxxxxxxxxxxxx</a>&gt;</li>
<li><em>In-reply-to</em>: &lt;<a href="msg00152.html">3F18A075.C6E13CE5@jays.net</a>&gt;</li>
<li><em>Sender</em>: <a href="mailto:owner-omaha-list@DOMAIN.HIDDEN">owner-omaha-list@xxxxxx</a></li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>Omaha PerlMongers One and All:

I suppose this concept is fundamentally more about *BSD and packet
filtering than it is about perl per se, but deadly.org recently posted
this perl goodie for creating realtime packet filter rules based on snort
output.
	<a  href="http://unix-geek.info/snort2pf.txt">http://unix-geek.info/snort2pf.txt</a>

Basically this enables a realtime intrusion prevention system.

I like Dengue's comments about the post:
&quot;Reactive IDS systems can be quite controversal, and require careful
configuration or you can wind up a victim of your own cleverness. Caveats
aside, budding BOFH's should give this a try.&quot;



Mat Caughron
PHP Consulting


On Fri, 18 Jul 2003, Jay Hannah wrote:
&gt; Laugh...
&gt;
&gt; At OSCON 2003 in one of Damian Conway's presentations he said that he
&gt; climbed to a mountaintop and meditated for 3 weeks in a full lotus, and
&gt; for one, brief moment he understood pack and unpack enough to port them
&gt; to Perl 6. He's since forgotten how it works again, but luckily he got
&gt; the code written before he lost his zen.
&gt;
&gt; I think he was only half kidding.
&gt;
&gt; unpack(&quot;C*&quot;, 'j, JAOPH');
&gt;
&gt;
&gt;
&gt;
&gt; -------- Original Message --------
&gt; Question:
&gt; How can I manipulate fixed-record-length files?
&gt;
&gt;     The most efficient way is using pack() and unpack(). This is faster
&gt;     than using substr() when take many, many strings. It is slower for
&gt;     just a few.
&gt;
&gt;     Here is a sample chunk of code to break up and put back together
&gt;     again some fixed-format input lines, in this case from the output
&gt;     of a normal, Berkeley-style ps:
&gt;
&gt;         # sample input line:
&gt;         #   15158 p5  T      0:00 perl /home/tchrist/scripts/now-what
&gt;         $PS_T = 'A6 A4 A7 A5 A*';
&gt;         open(PS, &quot;ps|&quot;);
&gt;         print scalar &lt;PS&gt;;
&gt;         while (&lt;PS&gt;) {
&gt;             ($pid, $tt, $stat, $time, $command) = unpack($PS_T, $_);
&gt;             for $var (qw!pid tt stat time command!) {
&gt;                 print &quot;$var: &lt;$$var&gt;\n&quot;;
&gt;             }
&gt;             print 'line=', pack($PS_T, $pid, $tt, $stat, $time,
&gt; $command),
&gt;                     &quot;\n&quot;;
&gt;         }
&gt;
&gt;     We've used `$$var' in a way that forbidden by `use strict 'refs''.
&gt;     That is, we've promoted a string to a scalar variable reference
&gt;     using symbolic references. This is ok in small programs, but
&gt;     doesn't scale well. It also only works on global variables, not
&gt;     lexicals.
&gt;


</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="00152" href="msg00152.html">[Fwd: Daily Perl FAQ - How can I manipulate fixed-record-length files?]</a></strong>
<ul><li><em>From:</em> Jay Hannah</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00155.html">[Fwd: [olug] Unix Tip: Rename files script]</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00157.html">Re: [Fwd: Daily Perl FAQ - What's the difference between require and use?]</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00152.html">[Fwd: Daily Perl FAQ - How can I manipulate fixed-record-length files?]</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00154.html">[Fwd: Daily Perl FAQ - What's the difference between require and use?]</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00156"><strong>Date</strong></a></li>
<li><a href="threads.html#00156"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
